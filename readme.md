# Dekamond Auth Challenge

## Overview

This project implements a secure, scalable OTP-based authentication system in Go, featuring rate limiting, user management, RESTful APIs, and containerization. The system follows clean architecture principles and uses modern Go practices for building enterprise-grade applications.

## üöÄ Features

### 1. OTP-Based Authentication

- **Phone-based registration/login**: Users authenticate using their phone number
- **Secure OTP generation**: Random 5-digit codes with cryptographic randomness
- **Time-limited OTPs**: Codes expire after 2 minutes for security
- **Console logging**: OTPs are printed to console (simulating SMS in development)
- **Automatic user creation**: New users are registered on first successful OTP verification
- **JWT token response**: Secure tokens for subsequent API authentication

### 2. Rate Limiting

- **Request throttling**: Maximum 3 OTP requests per phone number within 10 minutes
- **Redis-based tracking**: Distributed rate limiting using Redis counters
- **Automatic expiration**: Rate limit windows reset automatically

### 3. User Management

- **User retrieval**: Get individual user details by ID
- **User listing**: Paginated user list with search and filtering capabilities
- **Phone search**: Find users by partial phone number matching
- **Date filtering**: Filter users by registration date range
- **Secure endpoints**: Protected by JWT authentication

### 4. Security Features

- **JWT authentication**: Secure token-based API access
- **Bearer token support**: Standard Authorization header handling
- **Input validation**: Comprehensive request validation
- **SQL injection protection**: Parameterized queries throughout
- **Token expiration**: 1-hour JWT tokens with refresh token support

## üèóÔ∏è Clean Architecture Implementation

This project follows **Clean Architecture** principles with clear separation of concerns:

```
cmd/auth/                    # Application entry point
‚îú‚îÄ‚îÄ main.go                  # Dependency injection and startup

internal/
‚îú‚îÄ‚îÄ application/             # Application layer (dependency wiring)
‚îú‚îÄ‚îÄ controllers/             # Interface adapters (HTTP handlers)
‚îú‚îÄ‚îÄ dto/                     # Data Transfer Objects
‚îú‚îÄ‚îÄ entities/                # Enterprise business rules (core entities)
‚îú‚îÄ‚îÄ guards/                  # Authentication middleware
‚îú‚îÄ‚îÄ repositories/            # Data access layer (interface implementations)
‚îú‚îÄ‚îÄ routes/                  # HTTP route definitions
‚îî‚îÄ‚îÄ usecases/                # Application business rules (use cases)

pkg/                         # Shared packages
‚îú‚îÄ‚îÄ logger/                  # Logging utilities
‚îî‚îÄ‚îÄ utils/                   # Common utilities

config/                      # Configuration management
database/migrations/         # Database schema migrations
docs/                        # API documentation (Swagger)
```

### Architecture Layers

1. **Entities Layer** (`internal/entities/`)

   - Core business objects (User, JwtPayload)
   - Independent of external concerns
   - Contains enterprise business rules

2. **Use Cases Layer** (`internal/usecases/`)

   - Application-specific business rules
   - Orchestrates data flow between entities
   - Interfaces for external dependencies (repositories, external services)

3. **Interface Adapters Layer** (`internal/controllers/`, `internal/repositories/`)

   - Controllers: Convert HTTP requests/responses to use case calls
   - Repositories: Implement data access interfaces
   - Guards: Handle authentication logic

4. **Frameworks & Drivers Layer** (`cmd/`, external dependencies)
   - Web framework (Gin)
   - Database (PostgreSQL)
   - Cache (Redis)
   - HTTP server setup

### Dependency Inversion

- All dependencies point inward toward the use cases
- External concerns depend on abstractions (interfaces)
- Database and Redis are implementation details
- Easy to swap implementations without changing business logic

## üóÑÔ∏è Database Architecture

### PostgreSQL - Primary Database

**Why PostgreSQL?**

1. **ACID Compliance**: Ensures data consistency for user registration and authentication
2. **Concurrent Access**: Handles multiple simultaneous OTP verifications safely
3. **Robust Querying**: Advanced search capabilities for user management
4. **Reliability**: Production-proven database with excellent data durability
5. **Scalability**: Handles growing user bases with proper indexing and optimization
6. **JSON Support**: Future-ready for storing additional user metadata
7. **Migration Support**: Built-in schema versioning and migration capabilities

**Database Schema:**

```sql
CREATE TABLE users (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  phone varchar(20) NOT NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now()
);
```

**Key Design Decisions:**

- **Identity column**: Auto-incrementing primary key for efficient indexing
- **Unique phone constraint**: Prevents duplicate registrations
- **Timezone-aware timestamps**: Proper time handling across regions
- **Indexed phone column**: Fast user lookups during authentication

### Redis - Cache & Session Store

**Why Redis?**

1. **High Performance**: Sub-millisecond response times for OTP operations
2. **Atomic Operations**: Thread-safe counters for rate limiting
3. **TTL Support**: Automatic OTP expiration without cleanup jobs
4. **Memory Efficiency**: Optimal for temporary data (OTPs, rate limits)
5. **Scalability**: Horizontal scaling for high-traffic scenarios
6. **Persistence**: AOF persistence for rate limit durability
7. **Simple Operations**: Perfect fit for key-value OTP storage

**Redis Usage:**

- **OTP Storage**: `otp:code:{phone}` ‚Üí OTP value (2-minute TTL)
- **Rate Limiting**: `otp:10m:{phone}` ‚Üí Request count (10-minute TTL)
- **Automatic Cleanup**: Redis handles expiration automatically

### Database vs Cache Separation

**PostgreSQL for:**

- Permanent user data
- User registration records
- Audit trails and analytics
- Complex queries and reporting

**Redis for:**

- Temporary OTP codes
- Rate limiting counters
- Session-like data
- High-frequency operations

## üõ†Ô∏è Technology Stack

- **Language**: Go 1.24+
- **Web Framework**: Gin (high-performance HTTP framework)
- **Database**: PostgreSQL 16 (reliability and scalability)
- **Cache**: Redis 7 (high-performance key-value store)
- **Authentication**: JWT (JSON Web Tokens)
- **Validation**: go-playground/validator (struct validation)
- **Documentation**: Swagger/OpenAPI 3.0
- **Logging**: Zap (structured logging)
- **Migration**: golang-migrate (database migrations)
- **Testing**: Testify + Gomock (comprehensive testing)
- **Containerization**: Docker + Docker Compose

## üìã API Endpoints

### Authentication Routes

- `POST /api/v1/auth/request-otp` - Request OTP for phone number
- `POST /api/v1/auth/verify-otp` - Verify OTP and get JWT token

### User Management Routes (Protected)

- `GET /api/v1/users/:id` - Get user by ID
- `GET /api/v1/users` - List users with pagination and search

### System Routes

- `GET /swagger/index.html` - API documentation
- `GET /health` - Health check endpoint

## üöÄ Getting Started

### Prerequisites

- Go 1.24+
- Docker & Docker Compose (for containerized setup)
- PostgreSQL 16+ (for local development)
- Redis 7+ (for local development)

### Running with Docker (Recommended)

```bash
# Clone the repository
git clone <repository-url>
cd dekamond-auth-challenge

# Start all services
docker-compose up --build

# The API will be available at http://localhost:8080
# Swagger docs at http://localhost:8080/swagger/index.html
```

### Running Locally

1. **Set up environment variables:**

```bash
export HTTP_PORT=8080
export LOG_LEVEL=info
export PG_DSN="host=localhost user=admin password=pgpass123 dbname=auth_challenge port=5432 sslmode=disable"
export RUN_MIGRATIONS=true
export REDIS_ADDR="localhost:6379"
export REDIS_PASSWORD="redis123"
export REDIS_DB=1
export JWT_SECRET="mySecret"
```

2. **Run the application:**

```bash
go run cmd/auth/main.go
```

### üìù Example API Usage

#### 1. Request OTP

```bash
curl -X POST http://localhost:8080/api/v1/auth/request-otp \
  -H "Content-Type: application/json" \
  -d '{"phone": "+1234567890"}'
```

#### 2. Verify OTP (check console for OTP code)

```bash
curl -X POST http://localhost:8080/api/v1/auth/verify-otp \
  -H "Content-Type: application/json" \
  -d '{"phone": "+1234567890", "otp": "12345"}'
```

#### 3. Access Protected Endpoints

```bash
# Use the JWT token from step 2
curl -X GET http://localhost:8080/api/v1/users/1 \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

#### 4. List Users with Search

```bash
curl -X GET "http://localhost:8080/api/v1/users?search=+1234&page=1&limit=10" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

## üîß Development Commands

### Generate Swagger Documentation

```bash
make swagger-docs
```

### Create Database Migration

```bash
make migrate-create name=add_new_table
```

### Generate Mocks for Testing

```bash
make generate-usecase-mocks
make generate-repository-mocks
```

### Run Tests

```bash
# Run all tests
go test ./... -v

# Run with coverage
go test ./... -cover

# Run with race detection
go test ./... -race
```

## üß™ Testing

The project includes comprehensive unit tests with 68.1% code coverage:

- **Unit Tests**: All use cases thoroughly tested with mocks
- **Integration Tests**: Redis integration tests (skipped if Redis unavailable)
- **Race Condition Tests**: All tests pass race detection
- **Edge Case Coverage**: Input validation, error scenarios, boundary conditions

Run tests:

```bash
go test ./internal/usecases/... -v
```

## üìä Monitoring & Observability

- **Structured Logging**: JSON-formatted logs with Zap
- **Health Checks**: Database and Redis connectivity monitoring
- **API Documentation**: Interactive Swagger UI
- **Request Validation**: Comprehensive input validation with detailed error messages

## üîí Security Considerations

- **Input Validation**: All requests validated against defined schemas
- **SQL Injection Protection**: Parameterized queries throughout
- **Rate Limiting**: Prevents brute force OTP attacks
- **JWT Security**: Short-lived tokens with secure signing
- **Phone Number Validation**: Proper format validation
- **OTP Security**: Cryptographically secure random generation

## üåç Production Readiness

- **Docker Support**: Full containerization with multi-stage builds
- **Environment Configuration**: 12-factor app configuration
- **Database Migrations**: Automated schema management
- **Graceful Shutdown**: Proper resource cleanup
- **Error Handling**: Comprehensive error responses
- **Logging**: Production-ready structured logging

## üìñ API Documentation

Interactive API documentation is available at `/swagger/index.html` when running the application. The documentation includes:

- Complete endpoint specifications
- Request/response schemas
- Authentication requirements
- Example requests and responses

---

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch
3. Write tests for new functionality
4. Run the test suite
5. Submit a pull request

## üìÑ License

This project is licensed under the MIT License.
